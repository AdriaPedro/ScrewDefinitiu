<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="24.05.0.0">
<procedure name="Measurements">
<interface>
<io>
<par name="RegionsCargols" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="CamParameters" base_type="ctrl" dimension="0"/>
<par name="objetos" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PositionScrew" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>*************************************</c>
<c>*              Variables</c>
<c>*************************************</c>
<c></c>
<l>NParts := 10</l>
<c></c>
<l>NBins := 5</l>
<c></c>
<c>*************************************</c>
<c></c>
<l>for Index := 0 to [objetos-1] by 1</l>
<c>    *Select one object to work with it</c>
<l>    select_obj(RegionsCargols, CargolTreball,[Index+1])</l>
<c>    </c>
<l>    PoseCamara := CamParameters.Pose</l>
<l>    CalibracionCamara := CamParameters.Calibration</l>
<l>    RefScale := CamParameters.Scale</l>
<c>    </c>
<c>    *Find the orientation and center of the object we are going to work with.                       </c>
<l>    orientation_region (CargolTreball, OrientacioCargolAmplada)</l>
<l>    area_center (CargolTreball, AreaCargolAmplada, FilaCentreAmplada, ColumnaCentreAmplada)</l>
<c>    </c>
<c>    *Sets the object vertically (theoretically).</c>
<l>    vector_angle_to_rigid (FilaCentreAmplada, ColumnaCentreAmplada, OrientacioCargolAmplada, \
    FilaCentreAmplada, ColumnaCentreAmplada, rad(90), CargolRotatAmpladaTeoric)</l>
<c>    </c>
<c>    *Places the object vertically (in practice).</c>
<l>    affine_trans_region (CargolTreball, CargolRotat, CargolRotatAmpladaTeoric, \
    'nearest_neighbor')</l>
<c>        </c>
<c>    *Makes the smallest rectangle that can fit in the part.</c>
<l>    smallest_rectangle1(CargolRotat, FilaAmplada1, ColumnaAmplada1, FilaAmplada2, ColumnaAmplada2)</l>
<l>    gen_rectangle1(RectangleAmplada, FilaAmplada1, ColumnaAmplada1, FilaAmplada2, ColumnaAmplada2)</l>
<c>        </c>
<c>    *Find the height and width of the rectangle</c>
<l>    region_features(RectangleAmplada,'width',AmpladaRectangle_Amplada)</l>
<l>    region_features(RectangleAmplada,'height',AlsadaRectangle_Amplada)</l>
<c>        </c>
<c>    *Split the rectangle in two by the height</c>
<c>    </c>
<l>    partition_rectangle(RectangleAmplada, QuadradoPartido, AmpladaRectangle_Amplada, AlsadaRectangle_Amplada/2)</l>
<l>    select_obj(QuadradoPartido,QuadradoPartido1,1)</l>
<l>    region_features(QuadradoPartido1,'width',AmpladaQuadrado_Amplada)</l>
<l>    region_features(QuadradoPartido1,'height',AlsadaQuadrado_Amplada)</l>
<l>    partition_rectangle(QuadradoPartido1, Partitioned, AmpladaQuadrado_Amplada, AlsadaQuadrado_Amplada/NParts)</l>
<c>    </c>
<l>    hom_mat2d_identity (HomMat2DIdentity)</l>
<l>    hom_mat2d_translate (HomMat2DIdentity, ColumnaCentreAmplada, FilaCentreAmplada, HomMat2DTranslate)</l>
<c>    </c>
<l>    for Index1:= 0 to NParts-1 by 1</l>
<c>        </c>
<l>            vector_angle_to_rigid (FilaCentreAmplada, ColumnaCentreAmplada, rad(90) , \
            FilaCentreAmplada, ColumnaCentreAmplada, OrientacioCargolAmplada, ScrewRotationCorrection)</l>
<l>            affine_trans_region (Partitioned, RotatedPartitions, ScrewRotationCorrection, \
            'nearest_neighbor')</l>
<c>            </c>
<c>           *Of the two remaining squares of the partition, we keep the top one.</c>
<l>           select_obj(RotatedPartitions, QuadradoPequenyo, [Index1]+1)</l>
<c>        </c>
<c>           *We look for the part that remains when we join the selected square and in the part of the snail that we are looking at</c>
<l>           intersection(QuadradoPequenyo,CargolTreball,PotaCargolAmplada)</l>
<c>           </c>
<c>           *From this resulting part, we look for the smallest rectangle that can fit</c>
<l>           smallest_rectangle2(PotaCargolAmplada, FilaPetitaAmplada1, ColumnaPetitaAmplada1,Phi, FilaPetitaAmplada2, ColumnaPetitaAmplada2)</l>
<l>           gen_rectangle2(RectangleMesuraAmplada, FilaPetitaAmplada1, ColumnaPetitaAmplada1,Phi, FilaPetitaAmplada2, ColumnaPetitaAmplada2) </l>
<l>           region_features(RectangleMesuraAmplada, 'row1', FilaPetitaAmplada1)</l>
<l>           region_features(RectangleMesuraAmplada, 'row2', FilaPetitaAmplada2)</l>
<l>           region_features(RectangleMesuraAmplada, 'column2', ColumnaPetitaAmplada2)</l>
<c>           </c>
<c>           *Calculates the distance between the points and stores it in a variable</c>
<l>           x1 := FilaPetitaAmplada1*RefScale</l>
<l>           x2 := FilaPetitaAmplada2*RefScale</l>
<l>           y1 := ColumnaPetitaAmplada2*RefScale</l>
<c>        </c>
<l>           distance_pp (x1,y1,x2,y1, Distance)</l>
<l>           Distance := Distance*1000</l>
<l>           amplada[Index1]:=Distance</l>
<l>    endfor</l>
<c>    </c>
<l>    Mode (amplada, NBins, AMPLADA)</l>
<l>    AMPLADATOTAL[Index] := AMPLADA</l>
<c>    </c>
<c>    </c>
<c> ********************************************</c>
<c> *                Length</c>
<c> ********************************************</c>
<c>    </c>
<c>    *Makes the smallest rectangle that can fit in the part.</c>
<l>    smallest_rectangle1(CargolRotat, FilaAlsada1, ColumnaAlsada1, FilaAlsada2, ColumnaAlsada2)</l>
<l>    gen_rectangle1(RectangleAlsada, FilaAlsada1, ColumnaAlsada1, FilaAlsada2, ColumnaAlsada2)</l>
<c>    </c>
<c>    *Makes the symmetrical difference between the screw and the rectangle.</c>
<l>    symm_difference(CargolRotat,RectangleAlsada,ContornsCargol)</l>
<c>        </c>
<c>    *From the regions we separate them</c>
<l>    connection(ContornsCargol, PartsContornCargol)</l>
<c>        </c>
<c>    *Select the region we are interested in, which in this case is 1.</c>
<l>    select_obj(PartsContornCargol, ObjecteTreball, 1)</l>
<c>        </c>
<c>    *We trim the sides to remove imperfections.</c>
<l>    opening_circle(ObjecteTreball, ObjecteTreballNetejat, 2)</l>
<c>        </c>
<c>    *Makes the smallest rectangle of the cleaned region we have searched for</c>
<l>    smallest_rectangle1(ObjecteTreballNetejat, FilaPetitaAlsada1, ColumnaPetitaAlsada1, FilaPetitaAlsada2, ColumnaPetitaAlsada2)</l>
<l>    gen_rectangle1(RectangleMesuraAlsada, FilaPetitaAlsada1, ColumnaPetitaAlsada1, FilaPetitaAlsada2, ColumnaPetitaAlsada2)</l>
<c>        </c>
<c>    *Calculates the distance between the points and stores it in a variable</c>
<l>    x1 := FilaPetitaAlsada1*RefScale</l>
<l>    x2 := FilaPetitaAlsada2*RefScale</l>
<l>    y2 := ColumnaPetitaAlsada1*RefScale</l>
<c>        </c>
<l>    distance_pp (x1,y2,x2,y2, Distance1)</l>
<l>    Distance1 := Distance1*1000</l>
<c>        </c>
<l>    altura[Index] := Distance1</l>
<c>    </c>
<l>    create_dict(PositionScrew)</l>
<c>    </c>
<l>    FilaCentre[Index] := FilaCentreAmplada</l>
<l>    ColumnaCentre[Index] := ColumnaCentreAmplada</l>
<l>    OrientacioCargol[Index] := deg(OrientacioCargolAmplada)</l>
<c>    </c>
<l>endfor</l>
<c></c>
<l>PositionScrew.Width := AMPLADATOTAL</l>
<l>PositionScrew.Height := altura</l>
<l>PositionScrew.Row := FilaCentre</l>
<l>PositionScrew.Column := ColumnaCentre</l>
<l>PositionScrew.RotZ := OrientacioCargol</l>
<c></c>
<l>return ()</l>
</body>
<docu id="Measurements">
<parameters>
<parameter id="CamParameters"/>
<parameter id="PositionScrew"/>
<parameter id="RegionsCargols"/>
<parameter id="objetos"/>
</parameters>
</docu>
</procedure>
</hdevelop>
