<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="24.05.0.0">
<procedure name="Measurements">
<interface>
<io>
<par name="RegionsCargols" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="CamParameters" base_type="ctrl" dimension="0"/>
<par name="objetos" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PositionScrew" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>*************************************</c>
<c>*              Variables</c>
<c>*************************************</c>
<c></c>
<l>NParts := 10</l>
<c></c>
<l>NBins := 5</l>
<c></c>
<c>*************************************</c>
<c></c>
<l>for Index := 0 to [objetos-1] by 1</l>
<c>    *Select one object to work with it</c>
<l>    select_obj(RegionsCargols, CargolTreball,[Index+1])</l>
<c>    </c>
<l>    PoseCamara := CamParameters.Pose</l>
<l>    CalibracionCamara := CamParameters.Calibration</l>
<l>    RefScale := CamParameters.Scale</l>
<c>    </c>
<c>    *Find the orientation and center of the object we are going to work with.                       </c>
<l>    orientation_region (CargolTreball, OrientacioCargolAmplada)</l>
<l>    area_center (CargolTreball, AreaCargolAmplada, FilaCentreAmplada, ColumnaCentreAmplada)</l>
<c>    </c>
<c>    *Sets the object vertically (theoretically).</c>
<l>    vector_angle_to_rigid (FilaCentreAmplada, ColumnaCentreAmplada, OrientacioCargolAmplada, \
    FilaCentreAmplada, ColumnaCentreAmplada, rad(90), CargolRotatAmpladaTeoric)</l>
<c>    </c>
<c>    *Places the object vertically (in practice).</c>
<l>    affine_trans_region (CargolTreball, CargolRotat, CargolRotatAmpladaTeoric, \
    'nearest_neighbor')</l>
<c>        </c>
<c>    *Makes the smallest rectangle that can fit in the part.</c>
<l>    smallest_rectangle1(CargolRotat, FilaAmplada1, ColumnaAmplada1, FilaAmplada2, ColumnaAmplada2)</l>
<l>    gen_rectangle1(RectangleAmplada, FilaAmplada1, ColumnaAmplada1, FilaAmplada2, ColumnaAmplada2)</l>
<c>        </c>
<c>    *Find the height and width of the rectangle</c>
<l>    region_features(RectangleAmplada,'width',AmpladaRectangle_Amplada)</l>
<l>    region_features(RectangleAmplada,'height',AlsadaRectangle_Amplada)</l>
<c>        </c>
<c>    *Split the rectangle in two by the height</c>
<c>    </c>
<l>    partition_rectangle(RectangleAmplada, QuadradoPartido, AmpladaRectangle_Amplada, AlsadaRectangle_Amplada/2)</l>
<l>    select_obj(QuadradoPartido,QuadradoPartido1,1)</l>
<l>    region_features(QuadradoPartido1,'width',AmpladaQuadrado_Amplada)</l>
<l>    region_features(QuadradoPartido1,'height',AlsadaQuadrado_Amplada)</l>
<l>    partition_rectangle(QuadradoPartido1, Partitioned, AmpladaQuadrado_Amplada, AlsadaQuadrado_Amplada/20)</l>
<l>    for Index1:= 0 to 19 by 1</l>
<c>           *de els dos quadrats resultans de la particio ens quedem el de adalt</c>
<l>           select_obj(Partitioned, QuadradoPequenyo, [Index1]+1)</l>
<l>           dilation_rectangle1(QuadradoPequenyo, RegionDilation, 50, 50)</l>
<c>           </c>
<c>           *busquem la part que que queda quan juntem el quadrat selecionat i la par del cargol que estem mirant </c>
<l>           intersection(RegionDilation,CargolRotat,PotaCargolAmplada)</l>
<c>        </c>
<c>           *d'aquesta part resultant li busquem el rectangle mes petit que pot entrar</c>
<l>           smallest_rectangle1(PotaCargolAmplada, FilaPetitaAmplada1, ColumnaPetitaAmplada1, FilaPetitaAmplada2, ColumnaPetitaAmplada2)</l>
<l>           gen_rectangle1(RectangleMesuraAmplada, FilaPetitaAmplada1, ColumnaPetitaAmplada1, FilaPetitaAmplada2, ColumnaPetitaAmplada2) </l>
<c>           *troba els ponts de la punta esquerra superior i la esquerra inferior</c>
<l>           image_points_to_world_plane(CalibracionCamara, PoseCamara, FilaPetitaAmplada1, ColumnaPetitaAmplada1, 'mm', X_amplada, Y_amplada)</l>
<l>           image_points_to_world_plane(CalibracionCamara, PoseCamara, FilaPetitaAmplada1, ColumnaPetitaAmplada2, 'mm', X1_amplada, Y1_amplada)</l>
<c>        </c>
<c>           *calcula la distancia entre els punts i la guarda en una variable</c>
<l>           x1 := FilaPetitaAmplada1*RefScale</l>
<l>           y1 := ColumnaPetitaAmplada1*RefScale</l>
<l>           y2 := ColumnaPetitaAmplada2*RefScale</l>
<c>        </c>
<l>           distance_pp (x1,y1,x1,y2, Distance)</l>
<l>           Distance := Distance*1000</l>
<l>           amplada[Index1]:=Distance</l>
<l>    endfor</l>
<c>    </c>
<l>    Mode (amplada, NBins, AMPLADA)</l>
<l>    AMPLADATOTAL[Index] := AMPLADA</l>
<c>    </c>
<c>    </c>
<c> ********************************************</c>
<c> *                Length</c>
<c> ********************************************</c>
<c>    </c>
<c>    *Makes the smallest rectangle that can fit in the part.</c>
<l>    smallest_rectangle1(CargolRotat, FilaAlsada1, ColumnaAlsada1, FilaAlsada2, ColumnaAlsada2)</l>
<l>    gen_rectangle1(RectangleAlsada, FilaAlsada1, ColumnaAlsada1, FilaAlsada2, ColumnaAlsada2)</l>
<c>    </c>
<c>    *Makes the symmetrical difference between the screw and the rectangle.</c>
<l>    symm_difference(CargolRotat,RectangleAlsada,ContornsCargol)</l>
<c>        </c>
<c>    *From the regions we separate them</c>
<l>    connection(ContornsCargol, PartsContornCargol)</l>
<c>        </c>
<c>    *Select the region we are interested in, which in this case is 1.</c>
<l>    select_obj(PartsContornCargol, ObjecteTreball, 1)</l>
<c>        </c>
<c>    *We trim the sides to remove imperfections.</c>
<l>    opening_circle(ObjecteTreball, ObjecteTreballNetejat, 2)</l>
<c>        </c>
<c>    *Makes the smallest rectangle of the cleaned region we have searched for</c>
<l>    smallest_rectangle1(ObjecteTreballNetejat, FilaPetitaAlsada1, ColumnaPetitaAlsada1, FilaPetitaAlsada2, ColumnaPetitaAlsada2)</l>
<l>    gen_rectangle1(RectangleMesuraAlsada, FilaPetitaAlsada1, ColumnaPetitaAlsada1, FilaPetitaAlsada2, ColumnaPetitaAlsada2)</l>
<c>        </c>
<c>    *Calculates the distance between the points and stores it in a variable</c>
<l>    x1 := FilaPetitaAlsada1*RefScale</l>
<l>    x2 := FilaPetitaAlsada2*RefScale</l>
<l>    y2 := ColumnaPetitaAlsada1*RefScale</l>
<c>        </c>
<l>    distance_pp (x1,y2,x2,y2, Distance1)</l>
<l>    Distance1 := Distance1*1000</l>
<c>        </c>
<l>    altura[Index] := Distance1</l>
<c>    </c>
<l>    create_dict(PositionScrew)</l>
<c>    </c>
<l>    FilaCentre[Index] := FilaCentreAmplada</l>
<l>    ColumnaCentre[Index] := ColumnaCentreAmplada</l>
<l>    OrientacioCargol[Index] := deg(OrientacioCargolAmplada)</l>
<c>    </c>
<l>endfor</l>
<c></c>
<l>PositionScrew.Width := AMPLADATOTAL</l>
<l>PositionScrew.Height := altura</l>
<l>PositionScrew.Row := FilaCentre</l>
<l>PositionScrew.Column := ColumnaCentre</l>
<l>PositionScrew.RotZ := OrientacioCargol</l>
<c></c>
<l>return ()</l>
</body>
<docu id="Measurements">
<parameters>
<parameter id="CamParameters"/>
<parameter id="PositionScrew"/>
<parameter id="RegionsCargols"/>
<parameter id="objetos"/>
</parameters>
</docu>
</procedure>
</hdevelop>
